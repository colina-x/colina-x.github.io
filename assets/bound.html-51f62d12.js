import{_ as e,V as d,W as o,$ as n}from"./framework-c6791857.js";const l={},c=n(`<p>lower_bound与upper_bound是C++标准库中提供的模板算法，这两个算法都是对有序容器进行二分查找，默认是使用<code>&lt;</code>，不同点在于lower_bound()返回第一个小于等于val的元素，upper_bound()返回第一个大于val的元素（默认查询范围内是满足&lt;，即有序）。</p><h2 id="lower-bound" tabindex="-1"><a class="header-anchor" href="#lower-bound" aria-hidden="true">#</a> lower_bound</h2><p><code>lower_bound(beg, end, val)</code></p><p><code>lower_bound(beg, end, val, comp)</code></p><p>有两个重载版本，返回一个迭代器，表示第一个小于等于val的元素，如果不存在，返回end。</p><p>示例：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>vector&lt;int&gt; nums{1, 2, 3, 3, 4, 4, 5, 10};
auto i1 = lower_bound(nums.begin(), nums.end(), 4) - nums.begin();
cout &lt;&lt; &quot;index: &quot; &lt;&lt; i1 &lt;&lt; &quot;, value: &quot; &lt;&lt; nums[i1] &lt;&lt; endl;

//out: index: 4, value: 4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于<code>comp</code>，默认的类似于<code>bool comp(const &amp;x, const &amp;val) return x &lt; val;</code>，第一个参数为搜索范围内的数值，第二个为查询的val。</p><h2 id="upper-bound" tabindex="-1"><a class="header-anchor" href="#upper-bound" aria-hidden="true">#</a> upper_bound</h2><p><code>upper_bound(beg, end, val)</code></p><p><code>upper_bound(beg, end, val, comp)</code></p><p>有两个重载版本，返回一个迭代器，表示第一个小于等于val的元素，如果不存在，返回end。</p><p>示例：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>vector&lt;int&gt; nums{1, 2, 3, 3, 4, 4, 5, 10};
auto i1 = upper_bound(nums.begin(), nums.end(), 4) - nums.begin();
cout &lt;&lt; &quot;index: &quot; &lt;&lt; i1 &lt;&lt; &quot;, value: &quot; &lt;&lt; nums[i1] &lt;&lt; endl;

//out: index: 6, value: 5
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于<code>comp</code>，正好是相反的，默认的类似于<code>bool comp(const &amp;val, const &amp;x) return val &lt; x;</code>，第一个参数为查询的val，第二个为搜索范围内的数值。</p><h2 id="常见用法与注意事项" tabindex="-1"><a class="header-anchor" href="#常见用法与注意事项" aria-hidden="true">#</a> 常见用法与注意事项</h2><ul><li>在容器升序时（从小到大），<code>lower_bound(beg, end, val)</code>查找第一个大于等于val的元素，<code>upper_bound(beg, end, val)</code>查找第一个大于val的元素；</li><li>在容器降序时（从大到小），<code>lower_bound(beg, end, val, greater&lt;type&gt;())</code>查找第一个小于等于val的元素，<code>upper_bound(beg, end, val, greater&lt;type&gt;())</code>查找第一个小于val的元素；</li><li>有序指搜索范围内有序即可，对于<code>lower_bound</code>来说，使<code>comp</code>成立的元素都在不成立的左边，即<code>true</code>向右搜索，<code>false</code>向左搜索，返回第一个<strong>不符合</strong><code>comp</code>的迭代器；对<code>upper_bound</code>来说，使<code>comp</code>成立的元素都在不成立的右边，即<code>true</code>向左搜索，<code>false</code>向右搜索，返回第一个<strong>符合</strong><code>comp</code>的迭代器。只要满足这个要求就能正常使用。</li><li>只要求<em>前向迭代器</em>，对于支持<em>随机访问迭代器</em>的容器，会有更好的性能（<code>n logn</code>）。</li></ul>`,17),a=[c];function t(u,i){return d(),o("div",null,a)}const s=e(l,[["render",t],["__file","bound.html.vue"]]);export{s as default};
